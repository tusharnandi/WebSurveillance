@page "/BufferWhenNeeded"
@model VideoApp.Pages.BufferWhenNeededModel
@{
}
<style>
	#st-video {
	  position: relative;
	  width: 100%;
	  height: 100%;
	}
    #snd-video {
	  position: relative;
	  width: 100%;
	  height: 100%;
	}
</style>
<div>Work in progress...</div>
<video id="st-video" playsinline controls></video>
    <script>

        const mediaPlayer = document.querySelector("#st-video");
        const assetURL ="sample.webm"; //"Recording-1.webm"; // "sample.webm";
        const mimeCodec = 'video/webm; codecs="vp9"';

        var totalSegments = 100;
        var segmentLength = 0;
        var segmentDuration = 0;
        var bytesFetched = 0;
        var requestedSegments = [];

        for (var i = 0; i < totalSegments; ++i) requestedSegments[i] = false;

        var mediaSource = null;
        if ('MediaSource' in window && MediaSource.isTypeSupported(mimeCodec)) 
        {
            mediaSource = new MediaSource;
            //console.log(mediaSource.readyState); // closed
            mediaPlayer.src = URL.createObjectURL(mediaSource);
            mediaSource.addEventListener('sourceopen', sourceOpen);
        }
        else {
            console.error('Unsupported MIME type or codec: ', mimeCodec);
        }

        var sourceBuffer = null;
        function sourceOpen (_) 
        {
            sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
        
            getFileLength(assetURL, function (fileLength) 
            {
                console.log("Content Length: "+ fileLength);
                console.log((fileLength / 1024 / 1024).toFixed(2), 'MB');
                //totalLength = fileLength;
                segmentLength = Math.round(fileLength / totalSegments);

                console.log(`segmentLength:${segmentLength}`);
          
                //mediaPlayer.duration=60;  //TKN Hardcoded Duration

                //mediaSource.duration = +Infinity;

                fetchRange(assetURL, 0, segmentLength, appendSegment);
                
                requestedSegments[0] = true;
          
                
                mediaPlayer.addEventListener('timeupdate', checkBuffer);
          
                mediaPlayer.addEventListener('canplay', function (){

                    segmentDuration = mediaPlayer.duration / totalSegments;

                    console.log(`canplay: mediaPlayer.duration: ${mediaPlayer.duration}, totalSegments: ${totalSegments}, segmentDuration: ${segmentDuration}`);
                    mediaPlayer.play();
                });
                
                mediaPlayer.addEventListener('seeking', seek);
            });
        };

        function getFileLength (url, cb) {
        var xhr = new XMLHttpRequest;
        xhr.open('head', url);
        xhr.onload = function () {
            cb(xhr.getResponseHeader('content-length'));
            };
        xhr.send();
        };

        function fetchRange (url, start, end, cb) {
            var xhr = new XMLHttpRequest;
            xhr.open('get', url);
            xhr.responseType = 'arraybuffer';
            xhr.setRequestHeader('Range', 'bytes=' + start + '-' + end);
            xhr.onload = function () {
                console.log('fetched bytes: ', start, end);
                bytesFetched += end - start + 1;
                cb(xhr.response);
            };
            xhr.send();
        };

        function appendSegment (chunk) {

        //const blobSize=JSON.stringify(chunk).length;

        //const blob = new Blob(chunk, { type: "video/webm", size: blobSize  }); // the blob

        sourceBuffer.appendBuffer(chunk);

        //Set to Another Video 
        //console.log("Playing into Another Video Tag.!!!!");

        //let videoUrl2= URL.createObjectURL(chunk); // the blob
        //mediaPlayer2.src= videoUrl2;
        };

        function checkBuffer (_) {
        var currentSegment = getCurrentSegment();

        if (currentSegment === totalSegments && haveAllSegments()) 
        {
            console.log('last segment', mediaSource.readyState);
            mediaSource.endOfStream();
            mediaPlayer.removeEventListener('timeupdate', checkBuffer);
        } 
        else if (shouldFetchNextSegment(currentSegment)) 
        {
            requestedSegments[currentSegment] = true;
            console.log('time to fetch next chunk', mediaPlayer.currentTime);
            fetchRange(assetURL, bytesFetched, bytesFetched + segmentLength, appendSegment);
        }
        //console.log(video.currentTime, currentSegment, segmentDuration);
        };

        function seek (e) {
            console.log(e);
            if (mediaSource.readyState === 'open') {
                sourceBuffer.abort();
                console.log(mediaSource.readyState);
            } else {
                console.log('seek but not open?');
                console.log(mediaSource.readyState);
            }
        };

        function getCurrentSegment () {
            return ((mediaPlayer.currentTime / segmentDuration) | 0) + 1;
        };

        function haveAllSegments () {
            return requestedSegments.every(function (val) { return !!val; });
        };

        function shouldFetchNextSegment (currentSegment) 
        {
            return mediaPlayer.currentTime > segmentDuration * currentSegment * 0.8 &&
                !requestedSegments[currentSegment];
        };
    </script>